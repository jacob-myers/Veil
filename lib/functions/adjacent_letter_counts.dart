import 'package:tuple/tuple.dart';
import 'package:veil/data_structures/cryptext.dart';

Tuple2<Map<String, int>, Map<String, int>>adjacentLetterCounts(Cryptext cryptext, String char) {
  // Initialize as all 0.
  Map<String, int> instancesBeforeChar = Map.fromIterables(
      cryptext.alphabet.letters,
      List.generate(cryptext.alphabet.letters.length, (index) => 0));
  // Initialize as all 0.
  Map<String, int> instancesAfterChar = Map.fromIterables(
      cryptext.alphabet.letters,
      List.generate(cryptext.alphabet.letters.length, (index) => 0));

  for (int i = 0; i < cryptext.length; i++) {
    if (cryptext.lettersInAlphabet[i] == char) {
      i != 0 ? instancesBeforeChar.update(cryptext.lettersInAlphabet[i-1], (value) => value += 1) : null;
      i != cryptext.length - 1 ? instancesAfterChar.update(cryptext.lettersInAlphabet[i+1], (value) => value += 1) : null;
    }
  }
  return Tuple2(instancesBeforeChar, instancesAfterChar);
}

void main() {
  Cryptext text = Cryptext.fromString("THISISTEXT");
  print(adjacentLetterCounts(text, "T").item2);

  String hardcodedCiphertext = 'EBDCCOMDTTYBOCWHLOHYWHVPEYBHMUOHRHLMRJNHUMEZHLPOWNDROYDYBOWHLMDTTHROOVNOKKHREZDLLHTEYELSXRCOMELYBONHABOUOEHRTDUYBOTEUKYYEROWDDFYDRJUEZBYHLMEKOOYBOBDWWJPDDMKEZLYBEKEKHWWKDNUHQJOGOUJADMJKOORKKDTHRDXKRJYXRRJKYXULELHLMERTOOWELFELMHBDROKENFYDDRXNBCUOKKXUOHLMERLOUGDXKYBHYKPBOLYBOYHVERHLYXULOMDLYBOUHMEDHLMHSHJQKDLZPHKDLHLMHSHJQKDLZPHKDLHLMHSHJQKDLZPHKDLKDECXYRJBHLMKXCYBOJUOCWHJELZRJKDLZYBOAXYYOUTWEOKTWJHPHJERLDMMELRJBOHMWEFOJOHBRDGELRJBECKWEFOJOHBEZDYRJBHLMKXCYBOJUOCWHJELRJKDLZEFLDPERZDLLHAODFJOHBEYKHCHUYJELYBOXKHENHLHWRDKYKOOEYYBHYMUOHRERMUOHRELZAXYYBOUOKHGDENOELKEMORJBOHMKHJELJDXWWLOGOUUOHNBEYOGOUJKYOCERYHFELOGOUJRDGOERHFOTOOWKWDKYPEYBLDMEUONYEDLRJTHEYBEKKBHFELAXYEEZDYYHFOOCYUJELZDYYHFOOCRJBOHMBOWMBEZBYBOUOKHWPHJKZDLLHAOHLDYBOURDXLYHELERHWPHJKZDLLHPHLLHRHFOEYRDGOHWPHJKZDLLHAOHLXCBEWWAHYYWOKDROYEROKERZDLLHBHGOYDWDKOHELYHADXYBDPTHKYEZOYYBOUOHELYHADXYPBHYKPHEYELDLYBODYBOUKEMOEYKYBONWERAYBOKYUXZZWOKERTHNELZYBONBHLNOKERYHFELZKDROYEROKREZBYFLDNFROMDPLAXYLDERLDYAUOHFELZERHJLDYFLDPEYAXYYBOKOHUOYBORDROLYKYBHYERZDLLHUORORAOURDKYJOHBSXKYZDYYHFOOCZDELHLMEEZDYYHAOKYUDLZSXKYFOOCCXKBELZDLPONWHPOMPONBHELOMDXUBOHUYKELGHELPOSXRCOMLOGOUHKFELZPBJPOFEKKOMETOWWXLMOUJDXUKCOWWHWDGOLDDLONDXWMMOLJMDLYJDXOGOUKHJESXKYPHWFOMHPHJEPEWWHWPHJKPHLYJDXENHLYWEGOHWEOUXLLELZTDURJWETOEPEWWHWPHJKPHLYJDXENHROELWEFOHPUONFELZAHWWELOGOUBEYKDBHUMELWDGOHWWEPHLYOMPHKYDAUOHFJDXUPHWWKHWWJDXOGOUMEMPHKPUONFROJOHBJDXJDXPUONFROECXYJDXBEZBXCELYBOKFJHLMLDPJDXUOLDYNDRELZMDPLEYKWDPWJYXULOMJDXWOYROAXULHLMLDPPOUOHKBOKDLYBOZUDXLMPOPOUOZDDMPOPOUOZDWMFELMHMUOHRYBHYNHLYAOKDWMPOPOUOUEZBYYEWWPOPOUOLYAXEWYHBDROHLMPHYNBOMEYAXULEMEMLYPHLLHWOHGOJDXEMEMLYPHLLHWEOKYHUYOMYDNUJAXYYBOLUORORAOUOMENHLAXJRJKOWTTWDPOUKPUEYORJLHROELYBOKHLMYHWFYDRJKOWTTDUBDXUKKHJYBELZKJDXMDLYXLMOUKYHLMENHLYHFORJKOWTMHLNELZHLMENHLBDWMRJDPLBHLMJOHBENHLWDGOROAOYYOUYBHLJDXNHL';
  text = Cryptext.fromString(hardcodedCiphertext);
  print(adjacentLetterCounts(text, 'W'));
}